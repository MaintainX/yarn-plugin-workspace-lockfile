/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-workspace-lockfile",
factory: function (require) {
"use strict";var plugin=(()=>{var b=Object.defineProperty;var E=Object.getOwnPropertyDescriptor;var U=Object.getOwnPropertyNames;var V=Object.prototype.hasOwnProperty;var A=(p=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(p,{get:(i,r)=>(typeof require<"u"?require:i)[r]}):p)(function(p){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+p+'" is not supported')});var v=(p,i)=>{for(var r in i)b(p,r,{get:i[r],enumerable:!0})},z=(p,i,r,g)=>{if(i&&typeof i=="object"||typeof i=="function")for(let k of U(i))!V.call(p,k)&&k!==r&&b(p,k,{get:()=>i[k],enumerable:!(g=E(i,k))||g.enumerable});return p};var F=p=>z(b({},"__esModule",{value:!0}),p);var q={};v(q,{default:()=>O});var e=A("@yarnpkg/core"),y=A("@yarnpkg/fslib");async function K(p,i,r,{report:g,immutable:k,cache:W}){try{let m=new Set,h=i.manifest;for(let f of["dependencies","devDependencies","peerDependencies"]){let s=h.getForScope(f);r.configuration.get("enableVerboseLogging")&&g.reportInfo(e.MessageName.UNNAMED,`Found ${s.size} ${f}`);for(let n of s.values()){let l=r.workspaces.find(d=>d.manifest.raw.name===n.name||d.manifest.raw.name===`@${n.scope}/${n.name}`);if(l){let d=e.structUtils.makeDescriptor(e.structUtils.makeIdent(n.scope||"",n.name),n.range);m.add(d),r.configuration.get("enableVerboseLogging")&&g.reportInfo(e.MessageName.UNNAMED,`Added workspace dependency: ${e.structUtils.stringifyDescriptor(d)}`);for(let a of["dependencies","devDependencies","peerDependencies"]){let o=l.manifest.getForScope(a);for(let c of o.values()){let t=e.structUtils.makeDescriptor(e.structUtils.makeIdent(c.scope||"npm",c.name),c.range);m.add(t),r.configuration.get("enableVerboseLogging")&&g.reportInfo(e.MessageName.UNNAMED,`Added transitive dependency from workspace: ${e.structUtils.stringifyDescriptor(t)}`)}}}else{let d=n.scope?`@${n.scope}/${n.name}`:n.name,a=e.structUtils.parseIdent(d),o=n.range.startsWith("workspace:")||n.range.startsWith("npm:")?n.range:`npm:${n.range}`,c=e.structUtils.makeDescriptor(a,o);m.add(c),r.configuration.get("enableVerboseLogging")&&g.reportInfo(e.MessageName.UNNAMED,`Added dependency: ${e.structUtils.stringifyDescriptor(c)}`)}}}let w=new Map,L=new Set,D=new Map,S=f=>{let s=e.structUtils.parseDescriptor(f);return s.range.startsWith("workspace:")?e.structUtils.stringifyDescriptor(s):e.structUtils.stringifyDescriptor(e.structUtils.makeDescriptor(s,`npm:${s.range.replace(/^npm:/,"")}`))},N=f=>{let s=e.structUtils.stringifyDescriptor(f),n=S(s);if(L.has(n))return;let l=r.storedResolutions.get(f.descriptorHash);if(!l){r.configuration.get("enableVerboseLogging")&&g.reportInfo(e.MessageName.UNNAMED,`No resolution found for ${s}`);return}D.has(l)||D.set(l,new Set),D.get(l).add(f);let d=r.storedPackages.get(l);if(!d){r.configuration.get("enableVerboseLogging")&&g.reportInfo(e.MessageName.UNNAMED,`No package found for ${s}`);return}L.add(n);for(let[a,o]of d.dependencies)N(o);for(let[a,o]of d.peerDependencies)N(o)};for(let f of m)N(f);for(let[f,s]of D){let n=r.storedPackages.get(f);if(!n)continue;let l=Array.from(s).map(c=>e.structUtils.stringifyDescriptor(c)).filter(c=>!c.includes("virtual:")).sort();if(l.length===0)continue;let d=l.join(", "),a=new Map,o=new Map;for(let[c,t]of n.dependencies){let u=t.range.startsWith("virtual:")?`npm:${t.range.replace(/^virtual:[^#]+#npm:/,"")}`:t.range.startsWith("workspace:")||t.range.startsWith("npm:")?t.range:`npm:${t.range}`;a.set(e.structUtils.stringifyIdent(t),u)}for(let[c,t]of n.peerDependencies){let u=e.structUtils.stringifyIdent(t),I=t.range.startsWith("virtual:")?`npm:${t.range.replace(/^virtual:[^#]+#npm:/,"")}`:t.range.startsWith("workspace:")||t.range.startsWith("npm:")?t.range:`npm:${t.range}`;if(u.startsWith("@types/")&&n.peerDependenciesMeta.get(u)?.optional&&t.range==="*"){r.configuration.get("enableVerboseLogging")&&g.reportInfo(e.MessageName.UNNAMED,`Skipping optional @types peer dependency: ${u}@${I}`);continue}o.set(u,I)}w.set(d,{version:n.linkType===e.LinkType.SOFT&&n.reference.startsWith("workspace:")?"0.0.0-use.local":n.version,resolution:e.structUtils.stringifyLocator(n),dependencies:a,peerDependencies:o,bin:n.bin,checksum:r.storedChecksums.get(f)||"",languageName:n.languageName,linkType:n.linkType})}r.configuration.get("enableVerboseLogging")&&g.reportInfo(e.MessageName.UNNAMED,`Generated ${w.size} entries for workspace lockfile`);let P=Array.from(w.entries()).sort().map(([f,s])=>{let n=s.dependencies.size>0?`  dependencies:
${Array.from(s.dependencies.entries()).sort().map(([a,o])=>{let c=o.startsWith("workspace:")?o:`npm:${o.replace(/^npm:/,"")}`;return`    ${a.startsWith("@")?`"${a}"`:a}: "${c}"`}).join(`
`)}`:"",l=s.peerDependencies.size>0?`  peerDependencies:
${Array.from(s.peerDependencies.entries()).sort().map(([a,o])=>{let c=o.startsWith("workspace:")?o:`${o.replace(/^npm:/,"")}`,t=c.match(/[:\{\}\[\]\,&*#?<>=!%@\\]/)?`"${c}"`:c;return`    ${a.startsWith("@")?`"${a}"`:a}: ${t}`}).join(`
`)}`:"";return[`"${f}":`,`  version: ${s.version||"unknown"}`,`  resolution: "${s.resolution}"`,n,l,s.bin.size>0?`  bin:
${Array.from(s.bin.entries()).map(([a,o])=>`    ${a}: ${o}`).join(`
`)}`:"",`  checksum: ${s.checksum}`,`  languageName: ${s.languageName.toLowerCase()}`,`  linkType: ${s.linkType.toLowerCase()}`].filter(Boolean).join(`
`)+`
`}).join(`
`),T=W.cacheKey,M=`# This file is generated by running "yarn install" inside your project through the workspace-lockfile plugin.
# Manual changes might be lost - proceed with caution!

__metadata:
  version: ${r.lockfileLastVersion??"6"}
  cacheKey: ${T}

${P}`,$=y.ppath.join(i.cwd,"yarn.workspace.lock");if(k){if(await y.xfs.readFilePromise($,"utf-8")===M)return;g.reportError(e.MessageName.UNNAMED,`The lockfile ${$} would have been modified by this install, which is explicitly forbidden`)}else await y.xfs.writeFilePromise($,M),g.reportInfo(e.MessageName.UNNAMED,`Created ${$}`)}catch(m){let h=m instanceof Error?m.message:String(m);g.reportError(e.MessageName.UNNAMED,`Failed to generate lockfile for ${p}: ${h}`)}}var C={configuration:{enableVerboseLogging:{description:"If true, enables verbose logging for workspace lockfile generation",type:e.SettingsType.BOOLEAN,default:!1}},hooks:{async afterAllInstalled(p,i){i.persistProject!==!1&&await i.report.startTimerPromise("Workspace lockfiles step",async()=>{for(let r of p.workspaces){let g=r.manifest.raw.name||r.cwd;await i.report.startTimerPromise(`Generating lockfile for ${g}`,async()=>{await K(g,r,p,i)})}})}}},O=C;return F(q);})();
return plugin;
}
};
