/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-workspace-lockfile",
factory: function (require) {
"use strict";var plugin=(()=>{var u=Object.defineProperty;var E=Object.getOwnPropertyDescriptor;var S=Object.getOwnPropertyNames;var U=Object.prototype.hasOwnProperty;var M=(n=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(n,{get:(r,f)=>(typeof require<"u"?require:r)[f]}):n)(function(n){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+n+'" is not supported')});var h=(n,r)=>{for(var f in r)u(n,f,{get:r[f],enumerable:!0})},v=(n,r,f,g)=>{if(r&&typeof r=="object"||typeof r=="function")for(let k of S(r))!U.call(n,k)&&k!==f&&u(n,k,{get:()=>r[k],enumerable:!(g=E(r,k))||g.enumerable});return n};var F=n=>v(u({},"__esModule",{value:!0}),n);var H={};h(H,{default:()=>L});var e=M("@yarnpkg/core"),y=M("@yarnpkg/fslib"),z={hooks:{async afterAllInstalled(n,r){let f=n.workspaces;for(let g of f){if(g.cwd===n.cwd)continue;let k=g.manifest.raw.name||g.cwd;r.report.reportInfo(e.MessageName.UNNAMED,`Generating lockfile for ${k}...`);try{let m=new Set,N=g.manifest;for(let d of["dependencies","devDependencies","peerDependencies"]){let t=N.getForScope(d);r.report.reportInfo(e.MessageName.UNNAMED,`Found ${t.size} ${d}`);for(let i of t.values()){let a=n.workspaces.find(s=>s.manifest.raw.name===i.name||s.manifest.raw.name===`@${i.scope}/${i.name}`);if(a){let s=e.structUtils.makeDescriptor(e.structUtils.makeIdent(i.scope||"",i.name),i.range);m.add(s),r.report.reportInfo(e.MessageName.UNNAMED,`Added workspace dependency: ${e.structUtils.stringifyDescriptor(s)}`);for(let p of["dependencies","devDependencies","peerDependencies"]){let D=a.manifest.getForScope(p);for(let o of D.values()){let c=e.structUtils.makeDescriptor(e.structUtils.makeIdent(o.scope||"npm",o.name),o.range);m.add(c),r.report.reportInfo(e.MessageName.UNNAMED,`Added transitive dependency from workspace: ${e.structUtils.stringifyDescriptor(c)}`)}}}else{let s=Array.from(n.storedPackages.keys()).find(c=>{let A=n.storedPackages.get(c);return A&&A.name===i.name}),p=s?n.storedPackages.get(s):null,D=p?e.structUtils.parseIdent(p.name).scope:i.scope||"npm",o=e.structUtils.makeDescriptor(e.structUtils.makeIdent(D,i.name),i.range);m.add(o),r.report.reportInfo(e.MessageName.UNNAMED,`Added dependency: ${e.structUtils.stringifyDescriptor(o)}`)}}}let w=new Map,$=new Set,l=d=>{let t=e.structUtils.stringifyDescriptor(d);if($.has(t))return;$.add(t);let i=n.storedResolutions.get(d.descriptorHash);if(i){let a=n.storedPackages.get(i);if(!a){r.report.reportInfo(e.MessageName.UNNAMED,`No package found for ${t}`);return}let s=new Map,p=new Map;for(let[D,o]of a.dependencies)s.set(e.structUtils.stringifyIdent(o),o.range),l(o);for(let[D,o]of a.peerDependencies)p.set(e.structUtils.stringifyIdent(o),o.range),l(o);w.set(t,{version:a.version,resolution:e.structUtils.stringifyLocator(a),dependencies:s,peerDependencies:p})}else{let a=Array.from(n.storedPackages.keys()).find(o=>{let c=n.storedPackages.get(o);return c&&c.identHash===d.identHash});if(!a){r.report.reportInfo(e.MessageName.UNNAMED,`No resolution found for ${t}`);return}let s=n.storedPackages.get(a);if(!s){r.report.reportInfo(e.MessageName.UNNAMED,`No package found for ${t}`);return}let p=new Map,D=new Map;for(let[o,c]of s.dependencies)p.set(e.structUtils.stringifyIdent(c),c.range),l(c);for(let[o,c]of s.peerDependencies)D.set(e.structUtils.stringifyIdent(c),c.range),l(c);w.set(t,{version:s.version,resolution:e.structUtils.stringifyLocator(s),dependencies:p,peerDependencies:D})}};for(let d of m)l(d);r.report.reportInfo(e.MessageName.UNNAMED,`Generated ${w.size} entries for workspace lockfile`);let P=Array.from(w.entries()).map(([d,t])=>{let i=t.dependencies.size>0?`  dependencies:
${Array.from(t.dependencies.entries()).map(([s,p])=>`    "${s}": "${p}"
`).join("")}`:"",a=t.peerDependencies.size>0?`  peerDependencies:
${Array.from(t.peerDependencies.entries()).map(([s,p])=>`    "${s}": "${p}"
`).join("")}`:"";return`"${d}":
  version: "${t.version||"unknown"}"
  resolution: "${t.resolution}"
${i}${a}`}).join(`
`),I=y.ppath.join(g.cwd,"yarn.workspace.lock");await y.xfs.writeFilePromise(I,P),r.report.reportInfo(e.MessageName.UNNAMED,`Created ${I}`)}catch(m){let N=m instanceof Error?m.message:String(m);r.report.reportError(e.MessageName.UNNAMED,`Failed to generate lockfile for ${k}: ${N}`)}}}}},L=z;return F(H);})();
return plugin;
}
};
