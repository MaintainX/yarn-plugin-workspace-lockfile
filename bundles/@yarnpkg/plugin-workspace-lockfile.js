/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-workspace-lockfile",
factory: function (require) {
"use strict";var plugin=(()=>{var h=Object.defineProperty;var L=Object.getOwnPropertyDescriptor;var S=Object.getOwnPropertyNames;var E=Object.prototype.hasOwnProperty;var A=(n=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(n,{get:(r,o)=>(typeof require<"u"?require:r)[o]}):n)(function(n){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+n+'" is not supported')});var v=(n,r)=>{for(var o in r)h(n,o,{get:r[o],enumerable:!0})},P=(n,r,o,m)=>{if(r&&typeof r=="object"||typeof r=="function")for(let p of S(r))!E.call(n,p)&&p!==o&&h(n,p,{get:()=>r[p],enumerable:!(m=L(r,p))||m.enumerable});return n};var U=n=>P(h({},"__esModule",{value:!0}),n);var z={};v(z,{default:()=>R});var e=A("@yarnpkg/core"),k=A("@yarnpkg/fslib");async function D(n,r,o){let m=n.manifest.raw.name||n.cwd;o.reportInfo(e.MessageName.UNNAMED,`Generating lockfile for ${m}...`);try{let p=new Set,y=n.manifest;for(let g of["dependencies","devDependencies","peerDependencies"]){let s=y.getForScope(g);r.configuration.get("enableVerboseLogging")&&o.reportInfo(e.MessageName.UNNAMED,`Found ${s.size} ${g}`);for(let t of s.values()){let l=r.workspaces.find(f=>f.manifest.raw.name===t.name||f.manifest.raw.name===`@${t.scope}/${t.name}`);if(l){let f=e.structUtils.makeDescriptor(e.structUtils.makeIdent(t.scope||"",t.name),t.range);p.add(f),r.configuration.get("enableVerboseLogging")&&o.reportInfo(e.MessageName.UNNAMED,`Added workspace dependency: ${e.structUtils.stringifyDescriptor(f)}`);for(let c of["dependencies","devDependencies","peerDependencies"]){let i=l.manifest.getForScope(c);for(let d of i.values()){let a=e.structUtils.makeDescriptor(e.structUtils.makeIdent(d.scope||"npm",d.name),d.range);p.add(a),r.configuration.get("enableVerboseLogging")&&o.reportInfo(e.MessageName.UNNAMED,`Added transitive dependency from workspace: ${e.structUtils.stringifyDescriptor(a)}`)}}}else{let f=t.scope?`@${t.scope}/${t.name}`:t.name,c=e.structUtils.parseIdent(f),i=t.range.startsWith("workspace:")||t.range.startsWith("npm:")?t.range:`npm:${t.range}`,d=e.structUtils.makeDescriptor(c,i);p.add(d),r.configuration.get("enableVerboseLogging")&&o.reportInfo(e.MessageName.UNNAMED,`Added dependency: ${e.structUtils.stringifyDescriptor(d)}`)}}}let $=new Map,b=new Set,u=new Map,M=g=>{let s=e.structUtils.parseDescriptor(g);return s.range.startsWith("workspace:")?e.structUtils.stringifyDescriptor(s):e.structUtils.stringifyDescriptor(e.structUtils.makeDescriptor(s,`npm:${s.range.replace(/^npm:/,"")}`))},w=g=>{let s=e.structUtils.stringifyDescriptor(g),t=M(s);if(b.has(t))return;b.add(t);let l=r.storedResolutions.get(g.descriptorHash);if(!l){r.configuration.get("enableVerboseLogging")&&o.reportInfo(e.MessageName.UNNAMED,`No resolution found for ${s}`);return}u.has(l)||u.set(l,new Set),u.get(l).add(g);let f=r.storedPackages.get(l);if(!f){r.configuration.get("enableVerboseLogging")&&o.reportInfo(e.MessageName.UNNAMED,`No package found for ${s}`);return}for(let[c,i]of f.dependencies)w(i);for(let[c,i]of f.peerDependencies)w(i)};for(let g of p)w(g);for(let[g,s]of u){let t=r.storedPackages.get(g);if(!t)continue;let l=Array.from(s).map(d=>e.structUtils.stringifyDescriptor(d)).filter(d=>!d.includes("virtual:")).sort();if(l.length===0)continue;let f=l.join(", "),c=new Map,i=new Map;for(let[d,a]of t.dependencies){let N=a.range.startsWith("virtual:")?`npm:${a.range.replace(/^virtual:[^#]+#npm:/,"")}`:a.range.startsWith("workspace:")||a.range.startsWith("npm:")?a.range:`npm:${a.range}`;c.set(e.structUtils.stringifyIdent(a),N)}for(let[d,a]of t.peerDependencies){let N=a.range.startsWith("virtual:")?`npm:${a.range.replace(/^virtual:[^#]+#npm:/,"")}`:a.range.startsWith("workspace:")||a.range.startsWith("npm:")?a.range:`npm:${a.range}`;i.set(e.structUtils.stringifyIdent(a),N)}$.set(f,{version:t.version,resolution:e.structUtils.stringifyLocator(t),checksum:t.identHash,dependencies:c,peerDependencies:i})}r.configuration.get("enableVerboseLogging")&&o.reportInfo(e.MessageName.UNNAMED,`Generated ${$.size} entries for workspace lockfile`);let I=Array.from($.entries()).sort(([g],[s])=>g.localeCompare(s)).map(([g,s])=>{let t=s.dependencies.size>0?`  dependencies:
${Array.from(s.dependencies.entries()).sort(([c],[i])=>c.localeCompare(i)).map(([c,i])=>{let d=i.startsWith("workspace:")?i:`npm:${i.replace(/^npm:/,"")}`;return`    ${c.startsWith("@")?`"${c}"`:c}: "${d}"`}).join(`
`)}`:"",l=s.peerDependencies.size>0?`  peerDependencies:
${Array.from(s.peerDependencies.entries()).sort(([c],[i])=>c.localeCompare(i)).map(([c,i])=>{let d=i.startsWith("workspace:")?i:`npm:${i.replace(/^npm:/,"")}`;return`    ${c.startsWith("@")?`"${c}"`:c}: "${d}"`}).join(`
`)}`:"";return[`"${g}":`,`  version: ${s.version||"unknown"}`,`  resolution: "${s.resolution}"`,t,l].filter(Boolean).join(`
`)+`
`}).join(`
`),W=k.ppath.join(n.cwd,"yarn.workspace.lock");await k.xfs.writeFilePromise(W,I),o.reportInfo(e.MessageName.UNNAMED,`Created ${W}`)}catch(p){let y=p instanceof Error?p.message:String(p);o.reportError(e.MessageName.UNNAMED,`Failed to generate lockfile for ${m}: ${y}`)}}var V={configuration:{enableVerboseLogging:{description:"If true, enables verbose logging for workspace lockfile generation",type:e.SettingsType.BOOLEAN,default:!1}},hooks:{async afterAllInstalled(n,r){for(let o of n.workspaces)await D(o,n,r.report)},async afterWorkspaceDependencyAddition(n,r,o,m){await e.StreamReport.start({configuration:n.project.configuration,stdout:process.stdout},async p=>{await D(n,n.project,p)})},async afterWorkspaceDependencyRemoval(n,r,o){await e.StreamReport.start({configuration:n.project.configuration,stdout:process.stdout},async m=>{await D(n,n.project,m)})},async afterWorkspaceDependencyReplacement(n,r,o,m){await e.StreamReport.start({configuration:n.project.configuration,stdout:process.stdout},async p=>{await D(n,n.project,p)})}}},R=V;return U(z);})();
return plugin;
}
};
