/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-workspace-lockfile",
factory: function (require) {
"use strict";var plugin=(()=>{var w=Object.defineProperty;var L=Object.getOwnPropertyDescriptor;var S=Object.getOwnPropertyNames;var W=Object.prototype.hasOwnProperty;var h=(n=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(n,{get:(r,t)=>(typeof require<"u"?require:r)[t]}):n)(function(n){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+n+'" is not supported')});var E=(n,r)=>{for(var t in r)w(n,t,{get:r[t],enumerable:!0})},P=(n,r,t,m)=>{if(r&&typeof r=="object"||typeof r=="function")for(let c of S(r))!W.call(n,c)&&c!==t&&w(n,c,{get:()=>r[c],enumerable:!(m=L(r,c))||m.enumerable});return n};var U=n=>P(w({},"__esModule",{value:!0}),n);var v={};E(v,{default:()=>R});var e=h("@yarnpkg/core"),k=h("@yarnpkg/fslib");async function D(n,r,t){let m=n.manifest.raw.name||n.cwd;t.reportInfo(e.MessageName.UNNAMED,`Generating lockfile for ${m}...`);try{let c=new Set,y=n.manifest;for(let p of["dependencies","devDependencies","peerDependencies"]){let s=y.getForScope(p);r.configuration.get("enableVerboseLogging")&&t.reportInfo(e.MessageName.UNNAMED,`Found ${s.size} ${p}`);for(let o of s.values()){let f=r.workspaces.find(d=>d.manifest.raw.name===o.name||d.manifest.raw.name===`@${o.scope}/${o.name}`);if(f){let d=e.structUtils.makeDescriptor(e.structUtils.makeIdent(o.scope||"",o.name),o.range);c.add(d),r.configuration.get("enableVerboseLogging")&&t.reportInfo(e.MessageName.UNNAMED,`Added workspace dependency: ${e.structUtils.stringifyDescriptor(d)}`);for(let a of["dependencies","devDependencies","peerDependencies"]){let i=f.manifest.getForScope(a);for(let g of i.values()){let l=e.structUtils.makeDescriptor(e.structUtils.makeIdent(g.scope||"npm",g.name),g.range);c.add(l),r.configuration.get("enableVerboseLogging")&&t.reportInfo(e.MessageName.UNNAMED,`Added transitive dependency from workspace: ${e.structUtils.stringifyDescriptor(l)}`)}}}else{let d=o.scope?`@${o.scope}/${o.name}`:o.name,a=e.structUtils.parseIdent(d),i=o.range.startsWith("workspace:")||o.range.startsWith("npm:")?o.range:`npm:${o.range}`,g=e.structUtils.makeDescriptor(a,i);c.add(g),r.configuration.get("enableVerboseLogging")&&t.reportInfo(e.MessageName.UNNAMED,`Added dependency: ${e.structUtils.stringifyDescriptor(g)}`)}}}let $=new Map,b=new Set,u=new Map,M=p=>{let s=e.structUtils.parseDescriptor(p);return s.range.startsWith("workspace:")?e.structUtils.stringifyDescriptor(s):e.structUtils.stringifyDescriptor(e.structUtils.makeDescriptor(s,`npm:${s.range.replace(/^npm:/,"")}`))},N=p=>{let s=e.structUtils.stringifyDescriptor(p),o=M(s);if(b.has(o))return;b.add(o);let f=r.storedResolutions.get(p.descriptorHash);if(!f){r.configuration.get("enableVerboseLogging")&&t.reportInfo(e.MessageName.UNNAMED,`No resolution found for ${s}`);return}u.has(f)||u.set(f,new Set),u.get(f).add(p);let d=r.storedPackages.get(f);if(!d){r.configuration.get("enableVerboseLogging")&&t.reportInfo(e.MessageName.UNNAMED,`No package found for ${s}`);return}for(let[a,i]of d.dependencies)N(i);for(let[a,i]of d.peerDependencies)N(i)};for(let p of c)N(p);for(let[p,s]of u){let o=r.storedPackages.get(p);if(!o)continue;let d=Array.from(s).map(g=>e.structUtils.stringifyDescriptor(g)).sort().join(", "),a=new Map,i=new Map;for(let[g,l]of o.dependencies)a.set(e.structUtils.stringifyIdent(l),l.range);for(let[g,l]of o.peerDependencies)i.set(e.structUtils.stringifyIdent(l),l.range);$.set(d,{version:o.version,resolution:e.structUtils.stringifyLocator(o),checksum:o.identHash,dependencies:a,peerDependencies:i})}r.configuration.get("enableVerboseLogging")&&t.reportInfo(e.MessageName.UNNAMED,`Generated ${$.size} entries for workspace lockfile`);let I=Array.from($.entries()).sort(([p],[s])=>p.localeCompare(s)).map(([p,s])=>{let o=s.dependencies.size>0?`  dependencies:
${Array.from(s.dependencies.entries()).sort(([a],[i])=>a.localeCompare(i)).map(([a,i])=>{let g=i.startsWith("workspace:")?i:`npm:${i.replace(/^npm:/,"")}`;return`    ${a.startsWith("@")?`"${a}"`:a}: "${g}"`}).join(`
`)}`:"",f=s.peerDependencies.size>0?`  peerDependencies:
${Array.from(s.peerDependencies.entries()).sort(([a],[i])=>a.localeCompare(i)).map(([a,i])=>{let g=i.startsWith("workspace:")?i:`npm:${i.replace(/^npm:/,"")}`;return`    ${a.startsWith("@")?`"${a}"`:a}: "${g}"`}).join(`
`)}`:"";return[`"${p}":`,`  version: ${s.version||"unknown"}`,`  resolution: "${s.resolution}"`,o,f].filter(Boolean).join(`
`)+`
`}).join(`
`),A=k.ppath.join(n.cwd,"yarn.workspace.lock");await k.xfs.writeFilePromise(A,I),t.reportInfo(e.MessageName.UNNAMED,`Created ${A}`)}catch(c){let y=c instanceof Error?c.message:String(c);t.reportError(e.MessageName.UNNAMED,`Failed to generate lockfile for ${m}: ${y}`)}}var V={configuration:{enableVerboseLogging:{description:"If true, enables verbose logging for workspace lockfile generation",type:e.SettingsType.BOOLEAN,default:!1}},hooks:{async afterAllInstalled(n,r){for(let t of n.workspaces)await D(t,n,r.report)},async afterWorkspaceDependencyAddition(n,r,t,m){await e.StreamReport.start({configuration:n.project.configuration,stdout:process.stdout},async c=>{await D(n,n.project,c)})},async afterWorkspaceDependencyRemoval(n,r,t){await e.StreamReport.start({configuration:n.project.configuration,stdout:process.stdout},async m=>{await D(n,n.project,m)})},async afterWorkspaceDependencyReplacement(n,r,t,m){await e.StreamReport.start({configuration:n.project.configuration,stdout:process.stdout},async c=>{await D(n,n.project,c)})}}},R=V;return U(v);})();
return plugin;
}
};
