/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-workspace-lockfile",
factory: function (require) {
"use strict";var plugin=(()=>{var N=Object.defineProperty;var E=Object.getOwnPropertyDescriptor;var P=Object.getOwnPropertyNames;var U=Object.prototype.hasOwnProperty;var A=(s=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(s,{get:(n,i)=>(typeof require<"u"?require:n)[i]}):s)(function(s){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+s+'" is not supported')});var V=(s,n)=>{for(var i in n)N(s,i,{get:n[i],enumerable:!0})},T=(s,n,i,u)=>{if(n&&typeof n=="object"||typeof n=="function")for(let f of P(n))!U.call(s,f)&&f!==i&&N(s,f,{get:()=>n[f],enumerable:!(u=E(n,f))||u.enumerable});return s};var C=s=>T(N({},"__esModule",{value:!0}),s);var R={};V(R,{default:()=>K});var e=A("@yarnpkg/core"),D=A("@yarnpkg/fslib");async function v(s,n,i){let u=s.manifest.raw.name||s.cwd;i.reportInfo(e.MessageName.UNNAMED,`Generating lockfile for ${u}...`);try{let f=new Set,$=s.manifest;for(let g of["dependencies","devDependencies","peerDependencies"]){let t=$.getForScope(g);n.configuration.get("enableVerboseLogging")&&i.reportInfo(e.MessageName.UNNAMED,`Found ${t.size} ${g}`);for(let r of t.values()){let l=n.workspaces.find(d=>d.manifest.raw.name===r.name||d.manifest.raw.name===`@${r.scope}/${r.name}`);if(l){let d=e.structUtils.makeDescriptor(e.structUtils.makeIdent(r.scope||"",r.name),r.range);f.add(d),n.configuration.get("enableVerboseLogging")&&i.reportInfo(e.MessageName.UNNAMED,`Added workspace dependency: ${e.structUtils.stringifyDescriptor(d)}`);for(let c of["dependencies","devDependencies","peerDependencies"]){let a=l.manifest.getForScope(c);for(let p of a.values()){let o=e.structUtils.makeDescriptor(e.structUtils.makeIdent(p.scope||"npm",p.name),p.range);f.add(o),n.configuration.get("enableVerboseLogging")&&i.reportInfo(e.MessageName.UNNAMED,`Added transitive dependency from workspace: ${e.structUtils.stringifyDescriptor(o)}`)}}}else{let d=r.scope?`@${r.scope}/${r.name}`:r.name,c=e.structUtils.parseIdent(d),a=r.range.startsWith("workspace:")||r.range.startsWith("npm:")?r.range:`npm:${r.range}`,p=e.structUtils.makeDescriptor(c,a);f.add(p),n.configuration.get("enableVerboseLogging")&&i.reportInfo(e.MessageName.UNNAMED,`Added dependency: ${e.structUtils.stringifyDescriptor(p)}`)}}}let y=new Map,w=new Set,k=new Map,I=g=>{let t=e.structUtils.parseDescriptor(g);return t.range.startsWith("workspace:")?e.structUtils.stringifyDescriptor(t):e.structUtils.stringifyDescriptor(e.structUtils.makeDescriptor(t,`npm:${t.range.replace(/^npm:/,"")}`))},h=g=>{let t=e.structUtils.stringifyDescriptor(g),r=I(t);if(w.has(r))return;let l=n.storedResolutions.get(g.descriptorHash);if(!l){n.configuration.get("enableVerboseLogging")&&i.reportInfo(e.MessageName.UNNAMED,`No resolution found for ${t}`);return}k.has(l)||k.set(l,new Set),k.get(l).add(g);let d=n.storedPackages.get(l);if(!d){n.configuration.get("enableVerboseLogging")&&i.reportInfo(e.MessageName.UNNAMED,`No package found for ${t}`);return}w.add(r);for(let[c,a]of d.dependencies)h(a);for(let[c,a]of d.peerDependencies)h(a)};for(let g of f)h(g);for(let[g,t]of k){let r=n.storedPackages.get(g);if(!r)continue;let l=Array.from(t).map(p=>e.structUtils.stringifyDescriptor(p)).filter(p=>!p.includes("virtual:")).sort();if(l.length===0)continue;let d=l.join(", "),c=new Map,a=new Map;for(let[p,o]of r.dependencies){let m=o.range.startsWith("virtual:")?`npm:${o.range.replace(/^virtual:[^#]+#npm:/,"")}`:o.range.startsWith("workspace:")||o.range.startsWith("npm:")?o.range:`npm:${o.range}`;c.set(e.structUtils.stringifyIdent(o),m)}for(let[p,o]of r.peerDependencies){let m=e.structUtils.stringifyIdent(o),M=o.range.startsWith("virtual:")?`npm:${o.range.replace(/^virtual:[^#]+#npm:/,"")}`:o.range.startsWith("workspace:")||o.range.startsWith("npm:")?o.range:`npm:${o.range}`;if(m.startsWith("@types/")&&r.peerDependenciesMeta.get(m)?.optional&&o.range==="*"){n.configuration.get("enableVerboseLogging")&&i.reportInfo(e.MessageName.UNNAMED,`Skipping optional @types peer dependency: ${m}@${M}`);continue}a.set(m,M)}y.set(d,{version:r.version,resolution:e.structUtils.stringifyLocator(r),dependencies:c,peerDependencies:a,bin:r.bin,checksum:n.storedChecksums.get(g)||"",languageName:r.languageName,linkType:r.linkType})}n.configuration.get("enableVerboseLogging")&&i.reportInfo(e.MessageName.UNNAMED,`Generated ${y.size} entries for workspace lockfile`);let L=Array.from(y.entries()).sort().map(([g,t])=>{let r=t.dependencies.size>0?`  dependencies:
${Array.from(t.dependencies.entries()).sort().map(([c,a])=>{let p=a.startsWith("workspace:")?a:`npm:${a.replace(/^npm:/,"")}`;return`    ${c.startsWith("@")?`"${c}"`:c}: "${p}"`}).join(`
`)}`:"",l=t.peerDependencies.size>0?`  peerDependencies:
${Array.from(t.peerDependencies.entries()).sort().map(([c,a])=>{let p=a.startsWith("workspace:")?a:`${a.replace(/^npm:/,"")}`,o=p.match(/[:\{\}\[\]\,&*#?<>=!%@\\]/)?`"${p}"`:p;return`    ${c.startsWith("@")?`"${c}"`:c}: ${o}`}).join(`
`)}`:"";return[`"${g}":`,`  version: ${t.version||"unknown"}`,`  resolution: "${t.resolution}"`,r,l,t.bin.size>0?`  bin:
${Array.from(t.bin.entries()).map(([c,a])=>`    ${c}: ${a}`).join(`
`)}`:"",`  checksum: ${t.checksum}`,`  languageName: ${t.languageName.toLowerCase()}`,`  linkType: ${t.linkType.toLowerCase()}`].filter(Boolean).join(`
`)+`
`}).join(`
`),{cacheKey:W}=e.Cache.getCacheKey(n.configuration),S=`# This file is generated by running "yarn install" inside your project through the workspace-lockfile plugin.
# Manual changes might be lost - proceed with caution!

__metadata:
  version: ${n.lockfileLastVersion}
  cacheKey: ${W}

${L}`,b=D.ppath.join(s.cwd,"yarn.workspace.lock");await D.xfs.writeFilePromise(b,S),i.reportInfo(e.MessageName.UNNAMED,`Created ${b}`)}catch(f){let $=f instanceof Error?f.message:String(f);i.reportError(e.MessageName.UNNAMED,`Failed to generate lockfile for ${u}: ${$}`)}}var z={configuration:{enableVerboseLogging:{description:"If true, enables verbose logging for workspace lockfile generation",type:e.SettingsType.BOOLEAN,default:!1}},hooks:{async afterAllInstalled(s,n){if(n.persistProject!==!1)for(let i of s.workspaces)await v(i,s,n.report)}}},K=z;return C(R);})();
return plugin;
}
};
