/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-workspace-lockfile",
factory: function (require) {
"use strict";var plugin=(()=>{var b=Object.defineProperty;var S=Object.getOwnPropertyDescriptor;var E=Object.getOwnPropertyNames;var P=Object.prototype.hasOwnProperty;var I=(n=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(n,{get:(r,t)=>(typeof require<"u"?require:r)[t]}):n)(function(n){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+n+'" is not supported')});var v=(n,r)=>{for(var t in r)b(n,t,{get:r[t],enumerable:!0})},U=(n,r,t,m)=>{if(r&&typeof r=="object"||typeof r=="function")for(let p of E(r))!P.call(n,p)&&p!==t&&b(n,p,{get:()=>r[p],enumerable:!(m=S(r,p))||m.enumerable});return n};var R=n=>U(b({},"__esModule",{value:!0}),n);var q={};v(q,{default:()=>C});var e=I("@yarnpkg/core"),y=I("@yarnpkg/fslib");function V(n,r,t){let m=e.structUtils.makeDescriptor(e.structUtils.parseIdent(r),t.startsWith("npm:")?t:`npm:${t}`);return n.storedResolutions.has(m.descriptorHash)}async function k(n,r,t){let m=n.manifest.raw.name||n.cwd;t.reportInfo(e.MessageName.UNNAMED,`Generating lockfile for ${m}...`);try{let p=new Set,$=n.manifest;for(let d of["dependencies","devDependencies","peerDependencies"]){let i=$.getForScope(d);r.configuration.get("enableVerboseLogging")&&t.reportInfo(e.MessageName.UNNAMED,`Found ${i.size} ${d}`);for(let o of i.values()){let l=r.workspaces.find(f=>f.manifest.raw.name===o.name||f.manifest.raw.name===`@${o.scope}/${o.name}`);if(l){let f=e.structUtils.makeDescriptor(e.structUtils.makeIdent(o.scope||"",o.name),o.range);p.add(f),r.configuration.get("enableVerboseLogging")&&t.reportInfo(e.MessageName.UNNAMED,`Added workspace dependency: ${e.structUtils.stringifyDescriptor(f)}`);for(let c of["dependencies","devDependencies","peerDependencies"]){let a=l.manifest.getForScope(c);for(let g of a.values()){let s=e.structUtils.makeDescriptor(e.structUtils.makeIdent(g.scope||"npm",g.name),g.range);p.add(s),r.configuration.get("enableVerboseLogging")&&t.reportInfo(e.MessageName.UNNAMED,`Added transitive dependency from workspace: ${e.structUtils.stringifyDescriptor(s)}`)}}}else{let f=o.scope?`@${o.scope}/${o.name}`:o.name,c=e.structUtils.parseIdent(f),a=o.range.startsWith("workspace:")||o.range.startsWith("npm:")?o.range:`npm:${o.range}`,g=e.structUtils.makeDescriptor(c,a);p.add(g),r.configuration.get("enableVerboseLogging")&&t.reportInfo(e.MessageName.UNNAMED,`Added dependency: ${e.structUtils.stringifyDescriptor(g)}`)}}}let N=new Map,W=new Set,D=new Map,M=d=>{let i=e.structUtils.parseDescriptor(d);return i.range.startsWith("workspace:")?e.structUtils.stringifyDescriptor(i):e.structUtils.stringifyDescriptor(e.structUtils.makeDescriptor(i,`npm:${i.range.replace(/^npm:/,"")}`))},h=d=>{let i=e.structUtils.stringifyDescriptor(d),o=M(i);if(W.has(o))return;W.add(o);let l=r.storedResolutions.get(d.descriptorHash);if(!l){r.configuration.get("enableVerboseLogging")&&t.reportInfo(e.MessageName.UNNAMED,`No resolution found for ${i}`);return}D.has(l)||D.set(l,new Set),D.get(l).add(d);let f=r.storedPackages.get(l);if(!f){r.configuration.get("enableVerboseLogging")&&t.reportInfo(e.MessageName.UNNAMED,`No package found for ${i}`);return}for(let[c,a]of f.dependencies)h(a);for(let[c,a]of f.peerDependencies)h(a)};for(let d of p)h(d);for(let[d,i]of D){let o=r.storedPackages.get(d);if(!o)continue;let l=Array.from(i).map(g=>e.structUtils.stringifyDescriptor(g)).filter(g=>!g.includes("virtual:")).sort();if(l.length===0)continue;let f=l.join(", "),c=new Map,a=new Map;for(let[g,s]of o.dependencies){let u=s.range.startsWith("virtual:")?`npm:${s.range.replace(/^virtual:[^#]+#npm:/,"")}`:s.range.startsWith("workspace:")||s.range.startsWith("npm:")?s.range:`npm:${s.range}`;c.set(e.structUtils.stringifyIdent(s),u)}for(let[g,s]of o.peerDependencies){let u=e.structUtils.stringifyIdent(s),w=s.range.startsWith("virtual:")?`npm:${s.range.replace(/^virtual:[^#]+#npm:/,"")}`:s.range.startsWith("workspace:")||s.range.startsWith("npm:")?s.range:`npm:${s.range}`;if(u.startsWith("@types/")&&!V(r,u,w)){r.configuration.get("enableVerboseLogging")&&t.reportInfo(e.MessageName.UNNAMED,`Skipping @types peer dependency not in main lockfile: ${u}@${w}`);continue}a.set(u,w)}N.set(f,{version:o.version,resolution:e.structUtils.stringifyLocator(o),checksum:o.identHash,dependencies:c,peerDependencies:a})}r.configuration.get("enableVerboseLogging")&&t.reportInfo(e.MessageName.UNNAMED,`Generated ${N.size} entries for workspace lockfile`);let L=Array.from(N.entries()).sort(([d],[i])=>d.localeCompare(i)).map(([d,i])=>{let o=i.dependencies.size>0?`  dependencies:
${Array.from(i.dependencies.entries()).sort(([c],[a])=>c.localeCompare(a)).map(([c,a])=>{let g=a.startsWith("workspace:")?a:`npm:${a.replace(/^npm:/,"")}`;return`    ${c.startsWith("@")?`"${c}"`:c}: "${g}"`}).join(`
`)}`:"",l=i.peerDependencies.size>0?`  peerDependencies:
${Array.from(i.peerDependencies.entries()).sort(([c],[a])=>c.localeCompare(a)).map(([c,a])=>{let g=a.startsWith("workspace:")?a:`${a.replace(/^npm:/,"")}`,s=g.match(/[:\{\}\[\]\,&*#?<>=!%@\\]/)?`"${g}"`:g;return`    ${c.startsWith("@")?`"${c}"`:c}: ${s}`}).join(`
`)}`:"";return[`"${d}":`,`  version: ${i.version||"unknown"}`,`  resolution: "${i.resolution}"`,o,l].filter(Boolean).join(`
`)+`
`}).join(`
`),A=y.ppath.join(n.cwd,"yarn.workspace.lock");await y.xfs.writeFilePromise(A,L),t.reportInfo(e.MessageName.UNNAMED,`Created ${A}`)}catch(p){let $=p instanceof Error?p.message:String(p);t.reportError(e.MessageName.UNNAMED,`Failed to generate lockfile for ${m}: ${$}`)}}var z={configuration:{enableVerboseLogging:{description:"If true, enables verbose logging for workspace lockfile generation",type:e.SettingsType.BOOLEAN,default:!1}},hooks:{async afterAllInstalled(n,r){for(let t of n.workspaces)await k(t,n,r.report)},async afterWorkspaceDependencyAddition(n,r,t,m){await e.StreamReport.start({configuration:n.project.configuration,stdout:process.stdout},async p=>{await k(n,n.project,p)})},async afterWorkspaceDependencyRemoval(n,r,t){await e.StreamReport.start({configuration:n.project.configuration,stdout:process.stdout},async m=>{await k(n,n.project,m)})},async afterWorkspaceDependencyReplacement(n,r,t,m){await e.StreamReport.start({configuration:n.project.configuration,stdout:process.stdout},async p=>{await k(n,n.project,p)})}}},C=z;return R(q);})();
return plugin;
}
};
