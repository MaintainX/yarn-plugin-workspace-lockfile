/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-workspace-lockfile",
factory: function (require) {
"use strict";var plugin=(()=>{var b=Object.defineProperty;var T=Object.getOwnPropertyDescriptor;var U=Object.getOwnPropertyNames;var V=Object.prototype.hasOwnProperty;var W=(i=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(i,{get:(r,o)=>(typeof require<"u"?require:r)[o]}):i)(function(i){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+i+'" is not supported')});var v=(i,r)=>{for(var o in r)b(i,o,{get:r[o],enumerable:!0})},z=(i,r,o,y)=>{if(r&&typeof r=="object"||typeof r=="function")for(let m of U(r))!V.call(i,m)&&m!==o&&b(i,m,{get:()=>r[m],enumerable:!(y=T(r,m))||y.enumerable});return i};var F=i=>z(b({},"__esModule",{value:!0}),i);var q={};v(q,{default:()=>O});var e=W("@yarnpkg/core"),k=W("@yarnpkg/fslib");async function K(i,r,{report:o,immutable:y,cache:m}){let M=i.manifest.raw.name||i.cwd;o.reportInfo(e.MessageName.UNNAMED,`Generating lockfile for ${M}...`);try{let l=new Set,h=i.manifest;for(let g of["dependencies","devDependencies","peerDependencies"]){let s=h.getForScope(g);r.configuration.get("enableVerboseLogging")&&o.reportInfo(e.MessageName.UNNAMED,`Found ${s.size} ${g}`);for(let n of s.values()){let d=r.workspaces.find(f=>f.manifest.raw.name===n.name||f.manifest.raw.name===`@${n.scope}/${n.name}`);if(d){let f=e.structUtils.makeDescriptor(e.structUtils.makeIdent(n.scope||"",n.name),n.range);l.add(f),r.configuration.get("enableVerboseLogging")&&o.reportInfo(e.MessageName.UNNAMED,`Added workspace dependency: ${e.structUtils.stringifyDescriptor(f)}`);for(let c of["dependencies","devDependencies","peerDependencies"]){let a=d.manifest.getForScope(c);for(let p of a.values()){let t=e.structUtils.makeDescriptor(e.structUtils.makeIdent(p.scope||"npm",p.name),p.range);l.add(t),r.configuration.get("enableVerboseLogging")&&o.reportInfo(e.MessageName.UNNAMED,`Added transitive dependency from workspace: ${e.structUtils.stringifyDescriptor(t)}`)}}}else{let f=n.scope?`@${n.scope}/${n.name}`:n.name,c=e.structUtils.parseIdent(f),a=n.range.startsWith("workspace:")||n.range.startsWith("npm:")?n.range:`npm:${n.range}`,p=e.structUtils.makeDescriptor(c,a);l.add(p),r.configuration.get("enableVerboseLogging")&&o.reportInfo(e.MessageName.UNNAMED,`Added dependency: ${e.structUtils.stringifyDescriptor(p)}`)}}}let w=new Map,I=new Set,D=new Map,S=g=>{let s=e.structUtils.parseDescriptor(g);return s.range.startsWith("workspace:")?e.structUtils.stringifyDescriptor(s):e.structUtils.stringifyDescriptor(e.structUtils.makeDescriptor(s,`npm:${s.range.replace(/^npm:/,"")}`))},N=g=>{let s=e.structUtils.stringifyDescriptor(g),n=S(s);if(I.has(n))return;let d=r.storedResolutions.get(g.descriptorHash);if(!d){r.configuration.get("enableVerboseLogging")&&o.reportInfo(e.MessageName.UNNAMED,`No resolution found for ${s}`);return}D.has(d)||D.set(d,new Set),D.get(d).add(g);let f=r.storedPackages.get(d);if(!f){r.configuration.get("enableVerboseLogging")&&o.reportInfo(e.MessageName.UNNAMED,`No package found for ${s}`);return}I.add(n);for(let[c,a]of f.dependencies)N(a);for(let[c,a]of f.peerDependencies)N(a)};for(let g of l)N(g);for(let[g,s]of D){let n=r.storedPackages.get(g);if(!n)continue;let d=Array.from(s).map(p=>e.structUtils.stringifyDescriptor(p)).filter(p=>!p.includes("virtual:")).sort();if(d.length===0)continue;let f=d.join(", "),c=new Map,a=new Map;for(let[p,t]of n.dependencies){let u=t.range.startsWith("virtual:")?`npm:${t.range.replace(/^virtual:[^#]+#npm:/,"")}`:t.range.startsWith("workspace:")||t.range.startsWith("npm:")?t.range:`npm:${t.range}`;c.set(e.structUtils.stringifyIdent(t),u)}for(let[p,t]of n.peerDependencies){let u=e.structUtils.stringifyIdent(t),A=t.range.startsWith("virtual:")?`npm:${t.range.replace(/^virtual:[^#]+#npm:/,"")}`:t.range.startsWith("workspace:")||t.range.startsWith("npm:")?t.range:`npm:${t.range}`;if(u.startsWith("@types/")&&n.peerDependenciesMeta.get(u)?.optional&&t.range==="*"){r.configuration.get("enableVerboseLogging")&&o.reportInfo(e.MessageName.UNNAMED,`Skipping optional @types peer dependency: ${u}@${A}`);continue}a.set(u,A)}w.set(f,{version:n.linkType===e.LinkType.SOFT&&n.reference.startsWith("workspace:")?"0.0.0-use.local":n.version,resolution:e.structUtils.stringifyLocator(n),dependencies:c,peerDependencies:a,bin:n.bin,checksum:r.storedChecksums.get(g)||"",languageName:n.languageName,linkType:n.linkType})}r.configuration.get("enableVerboseLogging")&&o.reportInfo(e.MessageName.UNNAMED,`Generated ${w.size} entries for workspace lockfile`);let E=Array.from(w.entries()).sort().map(([g,s])=>{let n=s.dependencies.size>0?`  dependencies:
${Array.from(s.dependencies.entries()).sort().map(([c,a])=>{let p=a.startsWith("workspace:")?a:`npm:${a.replace(/^npm:/,"")}`;return`    ${c.startsWith("@")?`"${c}"`:c}: "${p}"`}).join(`
`)}`:"",d=s.peerDependencies.size>0?`  peerDependencies:
${Array.from(s.peerDependencies.entries()).sort().map(([c,a])=>{let p=a.startsWith("workspace:")?a:`${a.replace(/^npm:/,"")}`,t=p.match(/[:\{\}\[\]\,&*#?<>=!%@\\]/)?`"${p}"`:p;return`    ${c.startsWith("@")?`"${c}"`:c}: ${t}`}).join(`
`)}`:"";return[`"${g}":`,`  version: ${s.version||"unknown"}`,`  resolution: "${s.resolution}"`,n,d,s.bin.size>0?`  bin:
${Array.from(s.bin.entries()).map(([c,a])=>`    ${c}: ${a}`).join(`
`)}`:"",`  checksum: ${s.checksum}`,`  languageName: ${s.languageName.toLowerCase()}`,`  linkType: ${s.linkType.toLowerCase()}`].filter(Boolean).join(`
`)+`
`}).join(`
`),P=m.cacheKey,L=`# This file is generated by running "yarn install" inside your project through the workspace-lockfile plugin.
# Manual changes might be lost - proceed with caution!

__metadata:
  version: ${r.lockfileLastVersion??"6"}
  cacheKey: ${P}

${E}`,$=k.ppath.join(i.cwd,"yarn.workspace.lock");if(y){if(await k.xfs.readFilePromise($,"utf-8")===L)return;o.reportError(e.MessageName.UNNAMED,`The lockfile ${$} would have been modified by this install, which is explicitly forbidden`)}else await k.xfs.writeFilePromise($,L),o.reportInfo(e.MessageName.UNNAMED,`Created ${$}`)}catch(l){let h=l instanceof Error?l.message:String(l);o.reportError(e.MessageName.UNNAMED,`Failed to generate lockfile for ${M}: ${h}`)}}var C={configuration:{enableVerboseLogging:{description:"If true, enables verbose logging for workspace lockfile generation",type:e.SettingsType.BOOLEAN,default:!1}},hooks:{async afterAllInstalled(i,r){if(r.persistProject!==!1)for(let o of i.workspaces)await K(o,i,r)}}},O=C;return F(q);})();
return plugin;
}
};
