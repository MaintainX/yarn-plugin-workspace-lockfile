/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-workspace-lockfile",
factory: function (require) {
"use strict";var plugin=(()=>{var w=Object.defineProperty;var L=Object.getOwnPropertyDescriptor;var W=Object.getOwnPropertyNames;var E=Object.prototype.hasOwnProperty;var I=(n=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(n,{get:(r,o)=>(typeof require<"u"?require:r)[o]}):n)(function(n){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+n+'" is not supported')});var S=(n,r)=>{for(var o in r)w(n,o,{get:r[o],enumerable:!0})},h=(n,r,o,l)=>{if(r&&typeof r=="object"||typeof r=="function")for(let i of W(r))!E.call(n,i)&&i!==o&&w(n,i,{get:()=>r[i],enumerable:!(l=L(r,i))||l.enumerable});return n};var U=n=>h(w({},"__esModule",{value:!0}),n);var R={};S(R,{default:()=>V});var e=I("@yarnpkg/core"),u=I("@yarnpkg/fslib");async function D(n,r,o){let l=n.manifest.raw.name||n.cwd;o.reportInfo(e.MessageName.UNNAMED,`Generating lockfile for ${l}...`);try{let i=new Set,k=n.manifest;for(let g of["dependencies","devDependencies","peerDependencies"]){let s=k.getForScope(g);r.configuration.get("enableVerboseLogging")&&o.reportInfo(e.MessageName.UNNAMED,`Found ${s.size} ${g}`);for(let t of s.values()){let m=r.workspaces.find(c=>c.manifest.raw.name===t.name||c.manifest.raw.name===`@${t.scope}/${t.name}`);if(m){let c=e.structUtils.makeDescriptor(e.structUtils.makeIdent(t.scope||"",t.name),t.range);i.add(c),r.configuration.get("enableVerboseLogging")&&o.reportInfo(e.MessageName.UNNAMED,`Added workspace dependency: ${e.structUtils.stringifyDescriptor(c)}`);for(let p of["dependencies","devDependencies","peerDependencies"]){let a=m.manifest.getForScope(p);for(let d of a.values()){let f=e.structUtils.makeDescriptor(e.structUtils.makeIdent(d.scope||"npm",d.name),d.range);i.add(f),r.configuration.get("enableVerboseLogging")&&o.reportInfo(e.MessageName.UNNAMED,`Added transitive dependency from workspace: ${e.structUtils.stringifyDescriptor(f)}`)}}}else{let c=t.scope?`@${t.scope}/${t.name}`:t.name,p=e.structUtils.parseIdent(c),a=t.range.startsWith("workspace:")||t.range.startsWith("npm:")?t.range:`npm:${t.range}`,d=e.structUtils.makeDescriptor(p,a);i.add(d),r.configuration.get("enableVerboseLogging")&&o.reportInfo(e.MessageName.UNNAMED,`Added dependency: ${e.structUtils.stringifyDescriptor(d)}`)}}}let y=new Map,N=new Set,b=g=>{let s=e.structUtils.parseDescriptor(g);return s.range.startsWith("workspace:")?e.structUtils.stringifyDescriptor(s):e.structUtils.stringifyDescriptor(e.structUtils.makeDescriptor(s,`npm:${s.range.replace(/^npm:/,"")}`))},$=g=>{let s=e.structUtils.stringifyDescriptor(g),t=b(s);if(N.has(t))return;N.add(t);let m=r.storedResolutions.get(g.descriptorHash);if(!m){r.configuration.get("enableVerboseLogging")&&o.reportInfo(e.MessageName.UNNAMED,`No resolution found for ${s}`);return}let c=r.storedPackages.get(m);if(!c){r.configuration.get("enableVerboseLogging")&&o.reportInfo(e.MessageName.UNNAMED,`No package found for ${s}`);return}let p=new Map,a=new Map;for(let[d,f]of c.dependencies)p.set(e.structUtils.stringifyIdent(f),f.range),$(f);for(let[d,f]of c.peerDependencies)a.set(e.structUtils.stringifyIdent(f),f.range),$(f);y.set(t,{version:c.version,resolution:e.structUtils.stringifyLocator(c),dependencies:p,peerDependencies:a})};for(let g of i)$(g);r.configuration.get("enableVerboseLogging")&&o.reportInfo(e.MessageName.UNNAMED,`Generated ${y.size} entries for workspace lockfile`);let M=Array.from(y.entries()).sort(([g],[s])=>g.localeCompare(s)).map(([g,s])=>{let t=b(g),m=s.dependencies.size>0?`  dependencies:
${Array.from(s.dependencies.entries()).sort(([p],[a])=>p.localeCompare(a)).map(([p,a])=>{let d=a.startsWith("workspace:")?a:`npm:${a.replace(/^npm:/,"")}`;return`    "${p}": "${d}"
`}).join("")}`:"",c=s.peerDependencies.size>0?`  peerDependencies:
${Array.from(s.peerDependencies.entries()).sort(([p],[a])=>p.localeCompare(a)).map(([p,a])=>{let d=a.startsWith("workspace:")?a:`npm:${a.replace(/^npm:/,"")}`;return`    "${p}": "${d}"
`}).join("")}`:"";return`"${t}":
  version: ${s.version||"unknown"}
  resolution: "${s.resolution}"
${m}${c}`}).join(`
`),A=u.ppath.join(n.cwd,"yarn.workspace.lock");await u.xfs.writeFilePromise(A,M),o.reportInfo(e.MessageName.UNNAMED,`Created ${A}`)}catch(i){let k=i instanceof Error?i.message:String(i);o.reportError(e.MessageName.UNNAMED,`Failed to generate lockfile for ${l}: ${k}`)}}var P={configuration:{enableVerboseLogging:{description:"If true, enables verbose logging for workspace lockfile generation",type:e.SettingsType.BOOLEAN,default:!1}},hooks:{async afterAllInstalled(n,r){for(let o of n.workspaces)await D(o,n,r.report)},async afterWorkspaceDependencyAddition(n,r,o,l){await e.StreamReport.start({configuration:n.project.configuration,stdout:process.stdout},async i=>{await D(n,n.project,i)})},async afterWorkspaceDependencyRemoval(n,r,o){await e.StreamReport.start({configuration:n.project.configuration,stdout:process.stdout},async l=>{await D(n,n.project,l)})},async afterWorkspaceDependencyReplacement(n,r,o,l){await e.StreamReport.start({configuration:n.project.configuration,stdout:process.stdout},async i=>{await D(n,n.project,i)})}}},V=P;return U(R);})();
return plugin;
}
};
