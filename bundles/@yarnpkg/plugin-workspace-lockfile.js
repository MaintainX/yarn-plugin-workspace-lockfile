/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-workspace-lockfile",
factory: function (require) {
"use strict";var plugin=(()=>{var $=Object.defineProperty;var E=Object.getOwnPropertyDescriptor;var S=Object.getOwnPropertyNames;var U=Object.prototype.hasOwnProperty;var M=(n=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(n,{get:(r,t)=>(typeof require<"u"?require:r)[t]}):n)(function(n){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+n+'" is not supported')});var W=(n,r)=>{for(var t in r)$(n,t,{get:r[t],enumerable:!0})},h=(n,r,t,D)=>{if(r&&typeof r=="object"||typeof r=="function")for(let o of S(r))!U.call(n,o)&&o!==t&&$(n,o,{get:()=>r[o],enumerable:!(D=E(r,o))||D.enumerable});return n};var v=n=>h($({},"__esModule",{value:!0}),n);var L={};W(L,{default:()=>F});var e=M("@yarnpkg/core"),N=M("@yarnpkg/fslib");async function l(n,r,t){if(n.cwd===r.cwd)return;let D=n.manifest.raw.name||n.cwd;t.reportInfo(e.MessageName.UNNAMED,`Generating lockfile for ${D}...`);try{let o=new Set,m=n.manifest;for(let g of["dependencies","devDependencies","peerDependencies"]){let c=m.getForScope(g);t.reportInfo(e.MessageName.UNNAMED,`Found ${c.size} ${g}`);for(let a of c.values()){let f=r.workspaces.find(s=>s.manifest.raw.name===a.name||s.manifest.raw.name===`@${a.scope}/${a.name}`);if(f){let s=e.structUtils.makeDescriptor(e.structUtils.makeIdent(a.scope||"",a.name),a.range);o.add(s),t.reportInfo(e.MessageName.UNNAMED,`Added workspace dependency: ${e.structUtils.stringifyDescriptor(s)}`);for(let d of["dependencies","devDependencies","peerDependencies"]){let k=f.manifest.getForScope(d);for(let i of k.values()){let p=e.structUtils.makeDescriptor(e.structUtils.makeIdent(i.scope||"npm",i.name),i.range);o.add(p),t.reportInfo(e.MessageName.UNNAMED,`Added transitive dependency from workspace: ${e.structUtils.stringifyDescriptor(p)}`)}}}else{let s=Array.from(r.storedPackages.keys()).find(p=>{let I=r.storedPackages.get(p);return I&&I.name===a.name}),d=s?r.storedPackages.get(s):null,k=d?e.structUtils.parseIdent(d.name).scope:a.scope||"npm",i=e.structUtils.makeDescriptor(e.structUtils.makeIdent(k,a.name),a.range);o.add(i),t.reportInfo(e.MessageName.UNNAMED,`Added dependency: ${e.structUtils.stringifyDescriptor(i)}`)}}}let y=new Map,w=new Set,u=g=>{let c=e.structUtils.stringifyDescriptor(g);if(w.has(c))return;w.add(c);let a=r.storedResolutions.get(g.descriptorHash);if(a){let f=r.storedPackages.get(a);if(!f){t.reportInfo(e.MessageName.UNNAMED,`No package found for ${c}`);return}let s=new Map,d=new Map;for(let[k,i]of f.dependencies)s.set(e.structUtils.stringifyIdent(i),i.range),u(i);for(let[k,i]of f.peerDependencies)d.set(e.structUtils.stringifyIdent(i),i.range),u(i);y.set(c,{version:f.version,resolution:e.structUtils.stringifyLocator(f),dependencies:s,peerDependencies:d})}else{let f=Array.from(r.storedPackages.keys()).find(i=>{let p=r.storedPackages.get(i);return p&&p.identHash===g.identHash});if(!f){t.reportInfo(e.MessageName.UNNAMED,`No resolution found for ${c}`);return}let s=r.storedPackages.get(f);if(!s){t.reportInfo(e.MessageName.UNNAMED,`No package found for ${c}`);return}let d=new Map,k=new Map;for(let[i,p]of s.dependencies)d.set(e.structUtils.stringifyIdent(p),p.range),u(p);for(let[i,p]of s.peerDependencies)k.set(e.structUtils.stringifyIdent(p),p.range),u(p);y.set(c,{version:s.version,resolution:e.structUtils.stringifyLocator(s),dependencies:d,peerDependencies:k})}};for(let g of o)u(g);t.reportInfo(e.MessageName.UNNAMED,`Generated ${y.size} entries for workspace lockfile`);let P=Array.from(y.entries()).map(([g,c])=>{let a=c.dependencies.size>0?`  dependencies:
${Array.from(c.dependencies.entries()).map(([s,d])=>`    "${s}": "${d}"
`).join("")}`:"",f=c.peerDependencies.size>0?`  peerDependencies:
${Array.from(c.peerDependencies.entries()).map(([s,d])=>`    "${s}": "${d}"
`).join("")}`:"";return`"${g}":
  version: "${c.version||"unknown"}"
  resolution: "${c.resolution}"
${a}${f}`}).join(`
`),A=N.ppath.join(n.cwd,"yarn.workspace.lock");await N.xfs.writeFilePromise(A,P),t.reportInfo(e.MessageName.UNNAMED,`Created ${A}`)}catch(o){let m=o instanceof Error?o.message:String(o);t.reportError(e.MessageName.UNNAMED,`Failed to generate lockfile for ${D}: ${m}`)}}var R={hooks:{async afterAllInstalled(n,r){for(let t of n.workspaces)await l(t,n,r.report)},async afterWorkspaceDependencyAddition(n,r,t,D){let o=await e.StreamReport.start({configuration:n.project.configuration,stdout:process.stdout},async m=>{await l(n,n.project,m)})},async afterWorkspaceDependencyRemoval(n,r,t){let D=await e.StreamReport.start({configuration:n.project.configuration,stdout:process.stdout},async o=>{await l(n,n.project,o)})},async afterWorkspaceDependencyReplacement(n,r,t,D){let o=await e.StreamReport.start({configuration:n.project.configuration,stdout:process.stdout},async m=>{await l(n,n.project,m)})}}},F=R;return v(L);})();
return plugin;
}
};
