/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-workspace-lockfile",
factory: function (require) {
"use strict";var plugin=(()=>{var N=Object.defineProperty;var W=Object.getOwnPropertyDescriptor;var L=Object.getOwnPropertyNames;var E=Object.prototype.hasOwnProperty;var I=(n=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(n,{get:(r,o)=>(typeof require<"u"?require:r)[o]}):n)(function(n){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+n+'" is not supported')});var S=(n,r)=>{for(var o in r)N(n,o,{get:r[o],enumerable:!0})},U=(n,r,o,f)=>{if(r&&typeof r=="object"||typeof r=="function")for(let a of L(r))!E.call(n,a)&&a!==o&&N(n,a,{get:()=>r[a],enumerable:!(f=W(r,a))||f.enumerable});return n};var P=n=>U(N({},"__esModule",{value:!0}),n);var v={};S(v,{default:()=>R});var e=I("@yarnpkg/core"),D=I("@yarnpkg/fslib");async function u(n,r,o){let f=n.manifest.raw.name||n.cwd;o.reportInfo(e.MessageName.UNNAMED,`Generating lockfile for ${f}...`);try{let a=new Set,k=n.manifest;for(let d of["dependencies","devDependencies","peerDependencies"]){let s=k.getForScope(d);r.configuration.get("enableVerboseLogging")&&o.reportInfo(e.MessageName.UNNAMED,`Found ${s.size} ${d}`);for(let t of s.values()){let l=r.workspaces.find(p=>p.manifest.raw.name===t.name||p.manifest.raw.name===`@${t.scope}/${t.name}`);if(l){let p=e.structUtils.makeDescriptor(e.structUtils.makeIdent(t.scope||"",t.name),t.range);a.add(p),r.configuration.get("enableVerboseLogging")&&o.reportInfo(e.MessageName.UNNAMED,`Added workspace dependency: ${e.structUtils.stringifyDescriptor(p)}`);for(let m of["dependencies","devDependencies","peerDependencies"]){let c=l.manifest.getForScope(m);for(let i of c.values()){let g=e.structUtils.makeDescriptor(e.structUtils.makeIdent(i.scope||"npm",i.name),i.range);a.add(g),r.configuration.get("enableVerboseLogging")&&o.reportInfo(e.MessageName.UNNAMED,`Added transitive dependency from workspace: ${e.structUtils.stringifyDescriptor(g)}`)}}}else{let p=t.scope?`@${t.scope}/${t.name}`:t.name,m=e.structUtils.parseIdent(p),c=t.range.startsWith("workspace:")||t.range.startsWith("npm:")?t.range:`npm:${t.range}`,i=e.structUtils.makeDescriptor(m,c);a.add(i),r.configuration.get("enableVerboseLogging")&&o.reportInfo(e.MessageName.UNNAMED,`Added dependency: ${e.structUtils.stringifyDescriptor(i)}`)}}}let y=new Map,w=new Set,b=d=>{let s=e.structUtils.parseDescriptor(d);return s.range.startsWith("workspace:")?e.structUtils.stringifyDescriptor(s):e.structUtils.stringifyDescriptor(e.structUtils.makeDescriptor(s,`npm:${s.range.replace(/^npm:/,"")}`))},$=d=>{let s=e.structUtils.stringifyDescriptor(d),t=b(s);if(w.has(t))return;w.add(t);let l=r.storedResolutions.get(d.descriptorHash);if(!l){r.configuration.get("enableVerboseLogging")&&o.reportInfo(e.MessageName.UNNAMED,`No resolution found for ${s}`);return}let p=r.storedPackages.get(l);if(!p){r.configuration.get("enableVerboseLogging")&&o.reportInfo(e.MessageName.UNNAMED,`No package found for ${s}`);return}let m=new Map,c=new Map;for(let[i,g]of p.dependencies)m.set(e.structUtils.stringifyIdent(g),g.range),$(g);for(let[i,g]of p.peerDependencies)c.set(e.structUtils.stringifyIdent(g),g.range),$(g);y.set(t,{version:p.version,resolution:e.structUtils.stringifyLocator(p),checksum:p.identHash,dependencies:m,peerDependencies:c})};for(let d of a)$(d);r.configuration.get("enableVerboseLogging")&&o.reportInfo(e.MessageName.UNNAMED,`Generated ${y.size} entries for workspace lockfile`);let M=Array.from(y.entries()).sort(([d],[s])=>d.localeCompare(s)).map(([d,s])=>{let t=b(d),l=s.dependencies.size>0?`  dependencies:
${Array.from(s.dependencies.entries()).sort(([c],[i])=>c.localeCompare(i)).map(([c,i])=>{let g=i.startsWith("workspace:")?i:`npm:${i.replace(/^npm:/,"")}`;return`    ${c.startsWith("@")?`"${c}"`:c}: "${g}"`}).join(`
`)}`:"",p=s.peerDependencies.size>0?`  peerDependencies:
${Array.from(s.peerDependencies.entries()).sort(([c],[i])=>c.localeCompare(i)).map(([c,i])=>{let g=i.startsWith("workspace:")?i:`npm:${i.replace(/^npm:/,"")}`;return`    ${c.startsWith("@")?`"${c}"`:c}: "${g}"`}).join(`
`)}`:"";return[`"${t}":`,`  version: ${s.version||"unknown"}`,`  resolution: "${s.resolution}"`,l,p].filter(Boolean).join(`
`)+`
`}).join(`
`),A=D.ppath.join(n.cwd,"yarn.workspace.lock");await D.xfs.writeFilePromise(A,M),o.reportInfo(e.MessageName.UNNAMED,`Created ${A}`)}catch(a){let k=a instanceof Error?a.message:String(a);o.reportError(e.MessageName.UNNAMED,`Failed to generate lockfile for ${f}: ${k}`)}}var V={configuration:{enableVerboseLogging:{description:"If true, enables verbose logging for workspace lockfile generation",type:e.SettingsType.BOOLEAN,default:!1}},hooks:{async afterAllInstalled(n,r){for(let o of n.workspaces)await u(o,n,r.report)},async afterWorkspaceDependencyAddition(n,r,o,f){await e.StreamReport.start({configuration:n.project.configuration,stdout:process.stdout},async a=>{await u(n,n.project,a)})},async afterWorkspaceDependencyRemoval(n,r,o){await e.StreamReport.start({configuration:n.project.configuration,stdout:process.stdout},async f=>{await u(n,n.project,f)})},async afterWorkspaceDependencyReplacement(n,r,o,f){await e.StreamReport.start({configuration:n.project.configuration,stdout:process.stdout},async a=>{await u(n,n.project,a)})}}},R=V;return P(v);})();
return plugin;
}
};
