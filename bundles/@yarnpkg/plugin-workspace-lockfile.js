/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-workspace-lockfile",
factory: function (require) {
"use strict";var plugin=(()=>{var u=Object.defineProperty;var E=Object.getOwnPropertyDescriptor;var S=Object.getOwnPropertyNames;var U=Object.prototype.hasOwnProperty;var M=(n=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(n,{get:(r,f)=>(typeof require<"u"?require:r)[f]}):n)(function(n){if(typeof require<"u")return require.apply(this,arguments);throw new Error('Dynamic require of "'+n+'" is not supported')});var h=(n,r)=>{for(var f in r)u(n,f,{get:r[f],enumerable:!0})},v=(n,r,f,g)=>{if(r&&typeof r=="object"||typeof r=="function")for(let k of S(r))!U.call(n,k)&&k!==f&&u(n,k,{get:()=>r[k],enumerable:!(g=E(r,k))||g.enumerable});return n};var F=n=>v(u({},"__esModule",{value:!0}),n);var H={};h(H,{default:()=>z});var e=M("@yarnpkg/core"),y=M("@yarnpkg/fslib"),L={hooks:{async afterAllInstalled(n,r){let f=n.workspaces;for(let g of f){if(g.cwd===n.cwd)continue;let k=g.manifest.raw.name||g.cwd;r.report.reportInfo(e.MessageName.UNNAMED,`Generating lockfile for ${k}...`);try{let D=new Set,N=g.manifest;for(let d of["dependencies","devDependencies","peerDependencies"]){let t=N.getForScope(d);r.report.reportInfo(e.MessageName.UNNAMED,`Found ${t.size} ${d}`);for(let i of t.values()){let a=n.workspaces.find(o=>o.manifest.raw.name===i.name||o.manifest.raw.name===`@${i.scope}/${i.name}`);if(a){let o=e.structUtils.makeDescriptor(e.structUtils.makeIdent(i.scope||"",i.name),i.range);D.add(o),r.report.reportInfo(e.MessageName.UNNAMED,`Added workspace dependency: ${e.structUtils.stringifyDescriptor(o)}`);for(let p of["dependencies","devDependencies","peerDependencies"]){let m=a.manifest.getForScope(p);for(let s of m.values()){let c=e.structUtils.makeDescriptor(e.structUtils.makeIdent(s.scope||"npm",s.name),s.range);D.add(c),r.report.reportInfo(e.MessageName.UNNAMED,`Added transitive dependency from workspace: ${e.structUtils.stringifyDescriptor(c)}`)}}}else{let o=Array.from(n.storedPackages.keys()).find(c=>{let A=n.storedPackages.get(c);return A&&A.name===i.name}),p=o?n.storedPackages.get(o):null,m=p?e.structUtils.parseIdent(p.name).scope:i.scope||"npm",s=e.structUtils.makeDescriptor(e.structUtils.makeIdent(m,i.name),i.range);D.add(s),r.report.reportInfo(e.MessageName.UNNAMED,`Added dependency: ${e.structUtils.stringifyDescriptor(s)}`)}}}let w=new Map,$=new Set,l=d=>{let t=e.structUtils.stringifyDescriptor(d);if($.has(t))return;$.add(t);let i=n.storedResolutions.get(d.descriptorHash);if(i){let a=n.storedPackages.get(i);if(!a){r.report.reportInfo(e.MessageName.UNNAMED,`No package found for ${t}`);return}let o=new Map,p=new Map;for(let[m,s]of a.dependencies)o.set(e.structUtils.stringifyIdent(s),s.range),l(s);for(let[m,s]of a.peerDependencies)p.set(e.structUtils.stringifyIdent(s),s.range),l(s);w.set(t,{version:a.version,resolution:e.structUtils.stringifyLocator(a),dependencies:o,peerDependencies:p})}else{let a=Array.from(n.storedPackages.keys()).find(s=>{let c=n.storedPackages.get(s);return c&&c.identHash===d.identHash});if(!a){r.report.reportInfo(e.MessageName.UNNAMED,`No resolution found for ${t}`);return}let o=n.storedPackages.get(a);if(!o){r.report.reportInfo(e.MessageName.UNNAMED,`No package found for ${t}`);return}let p=new Map,m=new Map;for(let[s,c]of o.dependencies)p.set(e.structUtils.stringifyIdent(c),c.range),l(c);for(let[s,c]of o.peerDependencies)m.set(e.structUtils.stringifyIdent(c),c.range),l(c);w.set(t,{version:o.version,resolution:e.structUtils.stringifyLocator(o),dependencies:p,peerDependencies:m})}};for(let d of D)l(d);r.report.reportInfo(e.MessageName.UNNAMED,`Generated ${w.size} entries for workspace lockfile`);let P=Array.from(w.entries()).map(([d,t])=>{let i=t.dependencies.size>0?`  dependencies:
${Array.from(t.dependencies.entries()).map(([o,p])=>`    "${o}": "${p}"
`).join("")}`:"",a=t.peerDependencies.size>0?`  peerDependencies:
${Array.from(t.peerDependencies.entries()).map(([o,p])=>`    "${o}": "${p}"
`).join("")}`:"";return`"${d}":
  version: "${t.version||"unknown"}"
  resolution: "${t.resolution}"
${i}${a}`}).join(`
`),I=y.ppath.join(g.cwd,"yarn.workspace.lock");await y.xfs.writeFilePromise(I,P),r.report.reportInfo(e.MessageName.UNNAMED,`Created ${I}`)}catch(D){let N=D instanceof Error?D.message:String(D);r.report.reportError(e.MessageName.UNNAMED,`Failed to generate lockfile for ${k}: ${N}`)}}}}},z=L;return F(H);})();
return plugin;
}
};
