/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-workspace-lockfile",
factory: function (require) {
"use strict";var plugin=(()=>{var b=Object.defineProperty;var P=Object.getOwnPropertyDescriptor;var U=Object.getOwnPropertyNames;var V=Object.prototype.hasOwnProperty;var L=(i=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(i,{get:(n,o)=>(typeof require<"u"?require:n)[o]}):i)(function(i){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+i+'" is not supported')});var T=(i,n)=>{for(var o in n)b(i,o,{get:n[o],enumerable:!0})},v=(i,n,o,D)=>{if(n&&typeof n=="object"||typeof n=="function")for(let l of U(n))!V.call(i,l)&&l!==o&&b(i,l,{get:()=>n[l],enumerable:!(D=P(n,l))||D.enumerable});return i};var C=i=>v(b({},"__esModule",{value:!0}),i);var q={};T(q,{default:()=>F});var e=L("@yarnpkg/core"),k=L("@yarnpkg/fslib");async function z(i,n,{report:o,immutable:D}){let l=i.manifest.raw.name||i.cwd;o.reportInfo(e.MessageName.UNNAMED,`Generating lockfile for ${l}...`);try{let m=new Set,h=i.manifest;for(let g of["dependencies","devDependencies","peerDependencies"]){let t=h.getForScope(g);n.configuration.get("enableVerboseLogging")&&o.reportInfo(e.MessageName.UNNAMED,`Found ${t.size} ${g}`);for(let r of t.values()){let d=n.workspaces.find(f=>f.manifest.raw.name===r.name||f.manifest.raw.name===`@${r.scope}/${r.name}`);if(d){let f=e.structUtils.makeDescriptor(e.structUtils.makeIdent(r.scope||"",r.name),r.range);m.add(f),n.configuration.get("enableVerboseLogging")&&o.reportInfo(e.MessageName.UNNAMED,`Added workspace dependency: ${e.structUtils.stringifyDescriptor(f)}`);for(let c of["dependencies","devDependencies","peerDependencies"]){let a=d.manifest.getForScope(c);for(let p of a.values()){let s=e.structUtils.makeDescriptor(e.structUtils.makeIdent(p.scope||"npm",p.name),p.range);m.add(s),n.configuration.get("enableVerboseLogging")&&o.reportInfo(e.MessageName.UNNAMED,`Added transitive dependency from workspace: ${e.structUtils.stringifyDescriptor(s)}`)}}}else{let f=r.scope?`@${r.scope}/${r.name}`:r.name,c=e.structUtils.parseIdent(f),a=r.range.startsWith("workspace:")||r.range.startsWith("npm:")?r.range:`npm:${r.range}`,p=e.structUtils.makeDescriptor(c,a);m.add(p),n.configuration.get("enableVerboseLogging")&&o.reportInfo(e.MessageName.UNNAMED,`Added dependency: ${e.structUtils.stringifyDescriptor(p)}`)}}}let N=new Map,M=new Set,y=new Map,W=g=>{let t=e.structUtils.parseDescriptor(g);return t.range.startsWith("workspace:")?e.structUtils.stringifyDescriptor(t):e.structUtils.stringifyDescriptor(e.structUtils.makeDescriptor(t,`npm:${t.range.replace(/^npm:/,"")}`))},w=g=>{let t=e.structUtils.stringifyDescriptor(g),r=W(t);if(M.has(r))return;let d=n.storedResolutions.get(g.descriptorHash);if(!d){n.configuration.get("enableVerboseLogging")&&o.reportInfo(e.MessageName.UNNAMED,`No resolution found for ${t}`);return}y.has(d)||y.set(d,new Set),y.get(d).add(g);let f=n.storedPackages.get(d);if(!f){n.configuration.get("enableVerboseLogging")&&o.reportInfo(e.MessageName.UNNAMED,`No package found for ${t}`);return}M.add(r);for(let[c,a]of f.dependencies)w(a);for(let[c,a]of f.peerDependencies)w(a)};for(let g of m)w(g);for(let[g,t]of y){let r=n.storedPackages.get(g);if(!r)continue;let d=Array.from(t).map(p=>e.structUtils.stringifyDescriptor(p)).filter(p=>!p.includes("virtual:")).sort();if(d.length===0)continue;let f=d.join(", "),c=new Map,a=new Map;for(let[p,s]of r.dependencies){let u=s.range.startsWith("virtual:")?`npm:${s.range.replace(/^virtual:[^#]+#npm:/,"")}`:s.range.startsWith("workspace:")||s.range.startsWith("npm:")?s.range:`npm:${s.range}`;c.set(e.structUtils.stringifyIdent(s),u)}for(let[p,s]of r.peerDependencies){let u=e.structUtils.stringifyIdent(s),A=s.range.startsWith("virtual:")?`npm:${s.range.replace(/^virtual:[^#]+#npm:/,"")}`:s.range.startsWith("workspace:")||s.range.startsWith("npm:")?s.range:`npm:${s.range}`;if(u.startsWith("@types/")&&r.peerDependenciesMeta.get(u)?.optional&&s.range==="*"){n.configuration.get("enableVerboseLogging")&&o.reportInfo(e.MessageName.UNNAMED,`Skipping optional @types peer dependency: ${u}@${A}`);continue}a.set(u,A)}N.set(f,{version:r.version,resolution:e.structUtils.stringifyLocator(r),dependencies:c,peerDependencies:a,bin:r.bin,checksum:n.storedChecksums.get(g)||"",languageName:r.languageName,linkType:r.linkType})}n.configuration.get("enableVerboseLogging")&&o.reportInfo(e.MessageName.UNNAMED,`Generated ${N.size} entries for workspace lockfile`);let E=Array.from(N.entries()).sort().map(([g,t])=>{let r=t.dependencies.size>0?`  dependencies:
${Array.from(t.dependencies.entries()).sort().map(([c,a])=>{let p=a.startsWith("workspace:")?a:`npm:${a.replace(/^npm:/,"")}`;return`    ${c.startsWith("@")?`"${c}"`:c}: "${p}"`}).join(`
`)}`:"",d=t.peerDependencies.size>0?`  peerDependencies:
${Array.from(t.peerDependencies.entries()).sort().map(([c,a])=>{let p=a.startsWith("workspace:")?a:`${a.replace(/^npm:/,"")}`,s=p.match(/[:\{\}\[\]\,&*#?<>=!%@\\]/)?`"${p}"`:p;return`    ${c.startsWith("@")?`"${c}"`:c}: ${s}`}).join(`
`)}`:"";return[`"${g}":`,`  version: ${t.version||"unknown"}`,`  resolution: "${t.resolution}"`,r,d,t.bin.size>0?`  bin:
${Array.from(t.bin.entries()).map(([c,a])=>`    ${c}: ${a}`).join(`
`)}`:"",`  checksum: ${t.checksum}`,`  languageName: ${t.languageName.toLowerCase()}`,`  linkType: ${t.linkType.toLowerCase()}`].filter(Boolean).join(`
`)+`
`}).join(`
`),{cacheKey:S}=e.Cache.getCacheKey(n.configuration),I=`# This file is generated by running "yarn install" inside your project through the workspace-lockfile plugin.
# Manual changes might be lost - proceed with caution!

__metadata:
  version: ${n.lockfileLastVersion}
  cacheKey: ${S}

${E}`,$=k.ppath.join(i.cwd,"yarn.workspace.lock");if(D){if(await k.xfs.readFilePromise($,"utf-8")===I)return;o.reportError(e.MessageName.UNNAMED,`The lockfile ${$} would have been modified by this install, which is explicitly forbidden`)}else await k.xfs.writeFilePromise($,I),o.reportInfo(e.MessageName.UNNAMED,`Created ${$}`)}catch(m){let h=m instanceof Error?m.message:String(m);o.reportError(e.MessageName.UNNAMED,`Failed to generate lockfile for ${l}: ${h}`)}}var K={configuration:{enableVerboseLogging:{description:"If true, enables verbose logging for workspace lockfile generation",type:e.SettingsType.BOOLEAN,default:!1}},hooks:{async afterAllInstalled(i,n){if(n.persistProject!==!1)for(let o of i.workspaces)await z(o,i,n)}}},F=K;return C(q);})();
return plugin;
}
};
