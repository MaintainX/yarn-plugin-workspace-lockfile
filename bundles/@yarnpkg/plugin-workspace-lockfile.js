/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-workspace-lockfile",
factory: function (require) {
"use strict";var plugin=(()=>{var w=Object.defineProperty;var P=Object.getOwnPropertyDescriptor;var U=Object.getOwnPropertyNames;var V=Object.prototype.hasOwnProperty;var W=(n=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(n,{get:(t,i)=>(typeof require<"u"?require:t)[i]}):n)(function(n){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+n+'" is not supported')});var R=(n,t)=>{for(var i in t)w(n,i,{get:t[i],enumerable:!0})},T=(n,t,i,m)=>{if(t&&typeof t=="object"||typeof t=="function")for(let c of U(t))!V.call(n,c)&&c!==i&&w(n,c,{get:()=>t[c],enumerable:!(m=P(t,c))||m.enumerable});return n};var v=n=>T(w({},"__esModule",{value:!0}),n);var K={};R(K,{default:()=>z});var e=W("@yarnpkg/core"),y=W("@yarnpkg/fslib");async function D(n,t,i){let m=n.manifest.raw.name||n.cwd;i.reportInfo(e.MessageName.UNNAMED,`Generating lockfile for ${m}...`);try{let c=new Set,$=n.manifest;for(let d of["dependencies","devDependencies","peerDependencies"]){let o=$.getForScope(d);t.configuration.get("enableVerboseLogging")&&i.reportInfo(e.MessageName.UNNAMED,`Found ${o.size} ${d}`);for(let r of o.values()){let l=t.workspaces.find(f=>f.manifest.raw.name===r.name||f.manifest.raw.name===`@${r.scope}/${r.name}`);if(l){let f=e.structUtils.makeDescriptor(e.structUtils.makeIdent(r.scope||"",r.name),r.range);c.add(f),t.configuration.get("enableVerboseLogging")&&i.reportInfo(e.MessageName.UNNAMED,`Added workspace dependency: ${e.structUtils.stringifyDescriptor(f)}`);for(let p of["dependencies","devDependencies","peerDependencies"]){let a=l.manifest.getForScope(p);for(let g of a.values()){let s=e.structUtils.makeDescriptor(e.structUtils.makeIdent(g.scope||"npm",g.name),g.range);c.add(s),t.configuration.get("enableVerboseLogging")&&i.reportInfo(e.MessageName.UNNAMED,`Added transitive dependency from workspace: ${e.structUtils.stringifyDescriptor(s)}`)}}}else{let f=r.scope?`@${r.scope}/${r.name}`:r.name,p=e.structUtils.parseIdent(f),a=r.range.startsWith("workspace:")||r.range.startsWith("npm:")?r.range:`npm:${r.range}`,g=e.structUtils.makeDescriptor(p,a);c.add(g),t.configuration.get("enableVerboseLogging")&&i.reportInfo(e.MessageName.UNNAMED,`Added dependency: ${e.structUtils.stringifyDescriptor(g)}`)}}}let h=new Map,b=new Set,k=new Map,I=d=>{let o=e.structUtils.parseDescriptor(d);return o.range.startsWith("workspace:")?e.structUtils.stringifyDescriptor(o):e.structUtils.stringifyDescriptor(e.structUtils.makeDescriptor(o,`npm:${o.range.replace(/^npm:/,"")}`))},N=d=>{let o=e.structUtils.stringifyDescriptor(d),r=I(o);if(b.has(r))return;let l=t.storedResolutions.get(d.descriptorHash);if(!l){t.configuration.get("enableVerboseLogging")&&i.reportInfo(e.MessageName.UNNAMED,`No resolution found for ${o}`);return}k.has(l)||k.set(l,new Set),k.get(l).add(d);let f=t.storedPackages.get(l);if(!f){t.configuration.get("enableVerboseLogging")&&i.reportInfo(e.MessageName.UNNAMED,`No package found for ${o}`);return}b.add(r);for(let[p,a]of f.dependencies)N(a);for(let[p,a]of f.peerDependencies)N(a)};for(let d of c)N(d);for(let[d,o]of k){let r=t.storedPackages.get(d);if(!r)continue;let l=Array.from(o).map(g=>e.structUtils.stringifyDescriptor(g)).filter(g=>!g.includes("virtual:")).sort();if(l.length===0)continue;let f=l.join(", "),p=new Map,a=new Map;for(let[g,s]of r.dependencies){let u=s.range.startsWith("virtual:")?`npm:${s.range.replace(/^virtual:[^#]+#npm:/,"")}`:s.range.startsWith("workspace:")||s.range.startsWith("npm:")?s.range:`npm:${s.range}`;p.set(e.structUtils.stringifyIdent(s),u)}for(let[g,s]of r.peerDependencies){let u=e.structUtils.stringifyIdent(s),M=s.range.startsWith("virtual:")?`npm:${s.range.replace(/^virtual:[^#]+#npm:/,"")}`:s.range.startsWith("workspace:")||s.range.startsWith("npm:")?s.range:`npm:${s.range}`;if(u.startsWith("@types/")&&r.peerDependenciesMeta.get(u)?.optional&&s.range==="*"){t.configuration.get("enableVerboseLogging")&&i.reportInfo(e.MessageName.UNNAMED,`Skipping optional @types peer dependency: ${u}@${M}`);continue}a.set(u,M)}h.set(f,{version:r.version,resolution:e.structUtils.stringifyLocator(r),dependencies:p,peerDependencies:a,bin:r.bin,checksum:t.storedChecksums.get(d)||"",languageName:r.languageName,linkType:r.linkType})}t.configuration.get("enableVerboseLogging")&&i.reportInfo(e.MessageName.UNNAMED,`Generated ${h.size} entries for workspace lockfile`);let L=Array.from(h.entries()).sort().map(([d,o])=>{let r=o.dependencies.size>0?`  dependencies:
${Array.from(o.dependencies.entries()).sort().map(([p,a])=>{let g=a.startsWith("workspace:")?a:`npm:${a.replace(/^npm:/,"")}`;return`    ${p.startsWith("@")?`"${p}"`:p}: "${g}"`}).join(`
`)}`:"",l=o.peerDependencies.size>0?`  peerDependencies:
${Array.from(o.peerDependencies.entries()).sort().map(([p,a])=>{let g=a.startsWith("workspace:")?a:`${a.replace(/^npm:/,"")}`,s=g.match(/[:\{\}\[\]\,&*#?<>=!%@\\]/)?`"${g}"`:g;return`    ${p.startsWith("@")?`"${p}"`:p}: ${s}`}).join(`
`)}`:"";return[`"${d}":`,`  version: ${o.version||"unknown"}`,`  resolution: "${o.resolution}"`,r,l,o.bin.size>0?`  bin:
${Array.from(o.bin.entries()).map(([p,a])=>`    ${p}: ${a}`).join(`
`)}`:"",`  checksum: ${o.checksum}`,`  languageName: ${o.languageName.toLowerCase()}`,`  linkType: ${o.linkType.toLowerCase()}`].filter(Boolean).join(`
`)+`
`}).join(`
`),{cacheKey:S}=e.Cache.getCacheKey(t.configuration),E=`# This file is generated by running "yarn install" inside your project through the workspace-lockfile plugin.
# Manual changes might be lost - proceed with caution!

__metadata:
  version: ${t.lockfileLastVersion}
  cacheKey: ${S}

${L}`,A=y.ppath.join(n.cwd,"yarn.workspace.lock");await y.xfs.writeFilePromise(A,E),i.reportInfo(e.MessageName.UNNAMED,`Created ${A}`)}catch(c){let $=c instanceof Error?c.message:String(c);i.reportError(e.MessageName.UNNAMED,`Failed to generate lockfile for ${m}: ${$}`)}}var C={configuration:{enableVerboseLogging:{description:"If true, enables verbose logging for workspace lockfile generation",type:e.SettingsType.BOOLEAN,default:!1}},hooks:{async afterAllInstalled(n,t){for(let i of n.workspaces)await D(i,n,t.report)},async afterWorkspaceDependencyAddition(n,t,i,m){await e.StreamReport.start({configuration:n.project.configuration,stdout:process.stdout},async c=>{await D(n,n.project,c)})},async afterWorkspaceDependencyRemoval(n,t,i){await e.StreamReport.start({configuration:n.project.configuration,stdout:process.stdout},async m=>{await D(n,n.project,m)})},async afterWorkspaceDependencyReplacement(n,t,i,m){await e.StreamReport.start({configuration:n.project.configuration,stdout:process.stdout},async c=>{await D(n,n.project,c)})}}},z=C;return v(K);})();
return plugin;
}
};
