/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-workspace-lockfile",
factory: function (require) {
"use strict";var plugin=(()=>{var N=Object.defineProperty;var S=Object.getOwnPropertyDescriptor;var U=Object.getOwnPropertyNames;var R=Object.prototype.hasOwnProperty;var W=(n=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(n,{get:(r,t)=>(typeof require<"u"?require:r)[t]}):n)(function(n){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+n+'" is not supported')});var v=(n,r)=>{for(var t in r)N(n,t,{get:r[t],enumerable:!0})},z=(n,r,t,D)=>{if(r&&typeof r=="object"||typeof r=="function")for(let c of U(r))!R.call(n,c)&&c!==t&&N(n,c,{get:()=>r[c],enumerable:!(D=S(r,c))||D.enumerable});return n};var F=n=>z(N({},"__esModule",{value:!0}),n);var j={};v(j,{default:()=>L});var e=W("@yarnpkg/core"),$=W("@yarnpkg/fslib");async function u(n,r,t){if(n.cwd===r.cwd)return;let D=n.manifest.raw.name||n.cwd;t.reportInfo(e.MessageName.UNNAMED,`Generating lockfile for ${D}...`);try{let c=new Set,w=n.manifest;for(let m of["dependencies","devDependencies","peerDependencies"]){let s=w.getForScope(m);t.reportInfo(e.MessageName.UNNAMED,`Found ${s.size} ${m}`);for(let o of s.values()){let k=r.workspaces.find(i=>i.manifest.raw.name===o.name||i.manifest.raw.name===`@${o.scope}/${o.name}`);if(k){let i=e.structUtils.makeDescriptor(e.structUtils.makeIdent(o.scope||"",o.name),o.range);c.add(i),t.reportInfo(e.MessageName.UNNAMED,`Added workspace dependency: ${e.structUtils.stringifyDescriptor(i)}`);for(let d of["dependencies","devDependencies","peerDependencies"]){let a=k.manifest.getForScope(d);for(let f of a.values()){let p=e.structUtils.makeDescriptor(e.structUtils.makeIdent(f.scope||"npm",f.name),f.range);c.add(p),t.reportInfo(e.MessageName.UNNAMED,`Added transitive dependency from workspace: ${e.structUtils.stringifyDescriptor(p)}`)}}}else{let i=Array.from(r.storedPackages.keys()).find(E=>{let P=r.storedPackages.get(E);return P&&P.name===o.name}),d=i?r.storedPackages.get(i):null,a=o.scope?`@${o.scope}/${o.name}`:o.name,f=e.structUtils.parseIdent(a),p=o.range.startsWith("workspace:")||o.range.startsWith("npm:")?o.range:`npm:${o.range}`,g=e.structUtils.makeDescriptor(f,p);c.add(g),t.reportInfo(e.MessageName.UNNAMED,`Added dependency: ${e.structUtils.stringifyDescriptor(g)}`)}}}let y=new Map,A=new Set,I=m=>{let s=e.structUtils.parseDescriptor(m);return s.range.startsWith("workspace:")?e.structUtils.stringifyDescriptor(s):e.structUtils.stringifyDescriptor(e.structUtils.makeDescriptor(s,`npm:${s.range.replace(/^npm:/,"")}`))},l=m=>{let s=e.structUtils.stringifyDescriptor(m),o=I(s);if(A.has(o))return;A.add(o);let k=r.storedResolutions.get(m.descriptorHash);if(k){let i=r.storedPackages.get(k);if(!i){t.reportInfo(e.MessageName.UNNAMED,`No package found for ${s}`);return}let d=new Map,a=new Map;for(let[f,p]of i.dependencies)d.set(e.structUtils.stringifyIdent(p),p.range),l(p);for(let[f,p]of i.peerDependencies)a.set(e.structUtils.stringifyIdent(p),p.range),l(p);y.set(s,{version:i.version,resolution:e.structUtils.stringifyLocator(i),dependencies:d,peerDependencies:a})}else{let i=Array.from(r.storedPackages.keys()).find(p=>{let g=r.storedPackages.get(p);return g&&g.identHash===m.identHash});if(!i){t.reportInfo(e.MessageName.UNNAMED,`No resolution found for ${s}`);return}let d=r.storedPackages.get(i);if(!d){t.reportInfo(e.MessageName.UNNAMED,`No package found for ${s}`);return}let a=new Map,f=new Map;for(let[p,g]of d.dependencies)a.set(e.structUtils.stringifyIdent(g),g.range),l(g);for(let[p,g]of d.peerDependencies)f.set(e.structUtils.stringifyIdent(g),g.range),l(g);y.set(s,{version:d.version,resolution:e.structUtils.stringifyLocator(d),dependencies:a,peerDependencies:f})}};for(let m of c)l(m);t.reportInfo(e.MessageName.UNNAMED,`Generated ${y.size} entries for workspace lockfile`);let h=Array.from(y.entries()).map(([m,s])=>{let o=I(m),k=s.dependencies.size>0?`  dependencies:
${Array.from(s.dependencies.entries()).map(([d,a])=>{let f=a.startsWith("workspace:")?a:`npm:${a.replace(/^npm:/,"")}`;return`    "${d}": "${f}"
`}).join("")}`:"",i=s.peerDependencies.size>0?`  peerDependencies:
${Array.from(s.peerDependencies.entries()).map(([d,a])=>{let f=a.startsWith("workspace:")?a:`npm:${a.replace(/^npm:/,"")}`;return`    "${d}": "${f}"
`}).join("")}`:"";return`"${o}":
  version: "${s.version||"unknown"}"
  resolution: "${s.resolution}"
${k}${i}`}).join(`
`),M=$.ppath.join(n.cwd,"yarn.workspace.lock");await $.xfs.writeFilePromise(M,h),t.reportInfo(e.MessageName.UNNAMED,`Created ${M}`)}catch(c){let w=c instanceof Error?c.message:String(c);t.reportError(e.MessageName.UNNAMED,`Failed to generate lockfile for ${D}: ${w}`)}}var K={hooks:{async afterAllInstalled(n,r){for(let t of n.workspaces)await u(t,n,r.report)},async afterWorkspaceDependencyAddition(n,r,t,D){await e.StreamReport.start({configuration:n.project.configuration,stdout:process.stdout},async c=>{await u(n,n.project,c)})},async afterWorkspaceDependencyRemoval(n,r,t){await e.StreamReport.start({configuration:n.project.configuration,stdout:process.stdout},async D=>{await u(n,n.project,D)})},async afterWorkspaceDependencyReplacement(n,r,t,D){await e.StreamReport.start({configuration:n.project.configuration,stdout:process.stdout},async c=>{await u(n,n.project,c)})}}},L=K;return F(j);})();
return plugin;
}
};
